<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shade-Optimized Routing Calculator</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #controls {
            background: #fff;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        
        #controls h2 {
            margin-bottom: 0.5rem;
            color: #333;
        }
        
        .control-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.5rem;
            align-items: center;
        }
        
        select, button {
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        button {
            background: #667eea;
            color: white;
            cursor: pointer;
            border: none;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        #map {
            flex: 1;
        }
        
        #instructions {
            background: #f8f9fa;
            padding: 0.75rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 14px;
        }
        
        #results {
            background: #e3f2fd;
            padding: 1rem;
            margin-top: 0.5rem;
            border-radius: 4px;
            display: none;
        }
        
        .metric {
            display: inline-block;
            margin-right: 1.5rem;
        }
        
        .metric strong {
            color: #333;
        }
        
        .route-shortest {
            color: #2196F3;
            font-weight: bold;
        }
        
        .route-shadiest {
            color: #4CAF50;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h2>ðŸŒ³ Shade-Optimized Routing Calculator</h2>
        
        <div class="control-row">
            <label>Scenario:</label>
            <select id="scenario">
                <option value="summer_midday">Summer Midday</option>
                <option value="summer_morning">Summer Morning</option>
                <option value="summer_evening">Summer Evening</option>
                <option value="winter_midday">Winter Midday</option>
                <option value="winter_morning">Winter Morning</option>
                <option value="spring_midday">Spring Midday</option>
                <option value="fall_midday">Fall Midday</option>
            </select>
            
            <button id="reset">Reset</button>
        </div>
        
        <div id="instructions">
            <strong>How to use:</strong> Click anywhere on the map to set origin, then click again for destination. Routes will calculate automatically.
        </div>
        
        <div id="results">
            <div class="metric">
                <span class="route-shortest">Shortest:</span>
                <span id="shortest-dist">-</span> | 
                <span id="shortest-shade">-</span> shade
            </div>
            <div class="metric">
                <span class="route-shadiest">Shadiest:</span>
                <span id="shadiest-dist">-</span> | 
                <span id="shadiest-shade">-</span> shade | 
                <span id="detour">-</span> detour
            </div>
        </div>
    </div>
    
    <div id="map"></div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // App state
        let map, networkLayer, routeLayer;
        let nodes = [], edges = [], scenarios = [], metadata = {};
        let origin = null, destination = null;
        let currentScenario = 'summer_midday';
        
        // Initialize map
        async function init() {
            // Load data
            console.log('Loading network data...');
            nodes = await fetch('map_data/nodes.json').then(r => r.json());
            edges = await fetch('map_data/edges.json').then(r => r.json());
            scenarios = await fetch('map_data/scenarios.json').then(r => r.json());
            metadata = await fetch('map_data/metadata.json').then(r => r.json());
            
            console.log(`Loaded ${nodes.length} nodes, ${edges.length} edges`);
            
            // Create map
            const bounds = metadata.bounds;
            map = L.map('map').fitBounds([
                [bounds.south, bounds.west],
                [bounds.north, bounds.east]
            ]);
            
            // Add base map
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: 'Â© OpenStreetMap contributors Â© CARTO',
                maxZoom: 19
            }).addTo(map);
            
            // Add network layer
            networkLayer = L.layerGroup().addTo(map);
            routeLayer = L.layerGroup().addTo(map);
            
            drawNetwork();
            
            // Click handler
            map.on('click', handleMapClick);
            
            // Controls
            document.getElementById('scenario').addEventListener('change', e => {
                currentScenario = e.target.value;
                drawNetwork();
                if (origin && destination) {
                    calculateRoutes();
                }
            });
            
            document.getElementById('reset').addEventListener('click', reset);
        }
        
        function drawNetwork() {
            networkLayer.clearLayers();
            
            edges.forEach(edge => {
                const shade = edge.shade[currentScenario] || 0;
                const color = getShadeColor(shade);
                
                L.polyline(edge.geometry, {
                    color: color,
                    weight: 2,
                    opacity: 0.6
                }).addTo(networkLayer);
            });
        }
        
        function getShadeColor(shade) {
            // Color scale: red (no shade) to green (full shade)
            if (shade < 0.2) return '#d32f2f';
            if (shade < 0.4) return '#f57c00';
            if (shade < 0.6) return '#fbc02d';
            if (shade < 0.8) return '#689f38';
            return '#388e3c';
        }
        
        function handleMapClick(e) {
            if (!origin) {
                origin = e.latlng;
                L.marker(origin, {
                    icon: L.divIcon({
                        className: 'origin-marker',
                        html: '<div style="background:#2196F3;width:12px;height:12px;border-radius:50%;border:2px solid white;"></div>'
                    })
                }).addTo(routeLayer);
            } else if (!destination) {
                destination = e.latlng;
                L.marker(destination, {
                    icon: L.divIcon({
                        className: 'dest-marker',
                        html: '<div style="background:#f44336;width:12px;height:12px;border-radius:50%;border:2px solid white;"></div>'
                    })
                }).addTo(routeLayer);
                
                calculateRoutes();
            }
        }
        
        function calculateRoutes() {
            console.log('Calculating routes...');
            
            // Find nearest nodes
            const originNode = findNearestNode(origin);
            const destNode = findNearestNode(destination);
            
            // Calculate shortest path
            const shortestPath = dijkstra(originNode, destNode, false);
            
            // Calculate shadiest path
            const shadiestPath = dijkstra(originNode, destNode, true);
            
            // Draw routes
            drawRoute(shortestPath, '#2196F3', 4);
            drawRoute(shadiestPath, '#4CAF50', 4);
            
            // Show results
            displayResults(shortestPath, shadiestPath);
        }
        
        function findNearestNode(latlng) {
            let nearest = null;
            let minDist = Infinity;
            
            nodes.forEach(node => {
                const dist = Math.sqrt(
                    Math.pow(node.lat - latlng.lat, 2) +
                    Math.pow(node.lon - latlng.lng, 2)
                );
                if (dist < minDist) {
                    minDist = dist;
                    nearest = node.id;
                }
            });
            
            return nearest;
        }
        
        function dijkstra(start, end, useShade) {
            // Build adjacency list
            const graph = {};
            edges.forEach(edge => {
                if (!graph[edge.source]) graph[edge.source] = [];
                if (!graph[edge.target]) graph[edge.target] = [];
                
                const shade = edge.shade[currentScenario] || 0;
                const cost = useShade ? edge.length * (1 - 0.3 * shade) : edge.length;
                
                graph[edge.source].push({node: edge.target, cost, edge});
                graph[edge.target].push({node: edge.source, cost, edge});
            });
            
            // Dijkstra's algorithm
            const dist = {};
            const prev = {};
            const pq = [{node: start, cost: 0}];
            
            nodes.forEach(n => {
                dist[n.id] = Infinity;
                prev[n.id] = null;
            });
            dist[start] = 0;
            
            while (pq.length > 0) {
                pq.sort((a, b) => a.cost - b.cost);
                const {node: u} = pq.shift();
                
                if (u === end) break;
                
                if (!graph[u]) continue;
                
                graph[u].forEach(({node: v, cost, edge}) => {
                    const alt = dist[u] + cost;
                    if (alt < dist[v]) {
                        dist[v] = alt;
                        prev[v] = {node: u, edge};
                        pq.push({node: v, cost: alt});
                    }
                });
            }
            
            // Reconstruct path
            const path = [];
            let u = end;
            while (prev[u]) {
                path.unshift(prev[u].edge);
                u = prev[u].node;
            }
            
            return path;
        }
        
        function drawRoute(path, color, weight) {
            path.forEach(edge => {
                L.polyline(edge.geometry, {
                    color: color,
                    weight: weight,
                    opacity: 0.8
                }).addTo(routeLayer);
            });
        }
        
        function displayResults(shortestPath, shadiestPath) {
            const shortestDist = shortestPath.reduce((sum, e) => sum + e.length, 0);
            const shadiestDist = shadiestPath.reduce((sum, e) => sum + e.length, 0);
            
            const shortestShade = shortestPath.reduce((sum, e) => 
                sum + e.shade[currentScenario] * e.length, 0) / shortestDist;
            const shadiestShade = shadiestPath.reduce((sum, e) => 
                sum + e.shade[currentScenario] * e.length, 0) / shadiestDist;
            
            const detour = ((shadiestDist - shortestDist) / shortestDist * 100).toFixed(1);
            
            document.getElementById('shortest-dist').textContent = `${(shortestDist * 0.3048).toFixed(0)}m`;
            document.getElementById('shortest-shade').textContent = `${(shortestShade * 100).toFixed(0)}%`;
            document.getElementById('shadiest-dist').textContent = `${(shadiestDist * 0.3048).toFixed(0)}m`;
            document.getElementById('shadiest-shade').textContent = `${(shadiestShade * 100).toFixed(0)}%`;
            document.getElementById('detour').textContent = `+${detour}%`;
            
            document.getElementById('results').style.display = 'block';
        }
        
        function reset() {
            origin = null;
            destination = null;
            routeLayer.clearLayers();
            document.getElementById('results').style.display = 'none';
        }
        
        // Initialize on load
        init();
    </script>
</body>
</html>
