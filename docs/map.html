<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shade-Optimized Routing Calculator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        #map {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 60px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 400px;
        }
        
        .title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }
        
        select, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        button {
            background: #4285f4;
            color: white;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }
        
        button:hover {
            background: #357ae8;
        }
        
        .info-box {
            background: #f0f7ff;
            padding: 12px;
            border-radius: 4px;
            border-left: 3px solid #4285f4;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .metrics {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #eee;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }
        
        .metric-label {
            color: #666;
            font-weight: 500;
        }
        
        .metric-value {
            color: #333;
            font-weight: 600;
        }
        
        .error {
            background: #fee;
            border-left-color: #f44;
            color: #c00;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 2000;
            text-align: center;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4285f4;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Loading network data...</p>
    </div>
    
    <div id="map"></div>
    
    <div id="controls">
        <div class="title">ðŸŒ³ Shade-Optimized Routing Calculator</div>
        
        <div class="control-group">
            <label for="scenario">Scenario:</label>
            <select id="scenario">
                <option value="summer_midday">Summer Midday</option>
            </select>
        </div>
        
        <button id="reset">Reset</button>
        
        <div class="info-box" id="instructions">
            <strong>How to use:</strong> Click once to set <strong>origin</strong>, click again to set <strong>destination</strong>. Routes compute automatically: <strong>Shortest</strong> (blue) vs <strong>Shadiest</strong> (green).
        </div>
        
        <div class="metrics" id="metrics">
            <div class="metric-row">
                <span class="metric-label">Shortest Route:</span>
                <span class="metric-value" id="shortest-dist">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Shadiest Route:</span>
                <span class="metric-value" id="shadiest-dist">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Detour:</span>
                <span class="metric-value" id="detour">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Shade Gain:</span>
                <span class="metric-value" id="shade-gain">-</span>
            </div>
        </div>
    </div>
    
    <script>
        let map, nodes = [], edges = [], scenarios = [], metadata = {};
        let currentScenario = 'summer_midday';
        let originNode = null, destNode = null;
        let originMarker = null, destMarker = null;
        let networkLayers = [];
        let routeLayers = [];
        
        async function init() {
            try {
                // Load all data
                await loadData();
                
                // Initialize map
                initMap();
                
                // Draw network
                drawNetwork();
                
                // Setup controls
                setupControls();
                
                // Hide loading
                document.getElementById('loading').style.display = 'none';
                
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('loading').innerHTML = 
                    `<div class="error info-box">
                        <strong>Error loading map:</strong><br>
                        ${error.message}<br><br>
                        <small>Check browser console for details (F12)</small>
                    </div>`;
            }
        }
        
        async function loadData() {
            console.log('Loading data files...');
            
            // Load metadata
            const metadataRes = await fetch('map_data/metadata.json');
            if (!metadataRes.ok) throw new Error('Failed to load metadata.json');
            metadata = await metadataRes.json();
            console.log('âœ“ Metadata loaded');
            
            // Load scenarios
            const scenariosRes = await fetch('map_data/scenarios.json');
            if (!scenariosRes.ok) throw new Error('Failed to load scenarios.json');
            scenarios = await scenariosRes.json();
            console.log('âœ“ Scenarios loaded:', scenarios.length);
            
            // Load nodes
            const nodesRes = await fetch('map_data/nodes.json');
            if (!nodesRes.ok) throw new Error('Failed to load nodes.json');
            nodes = await nodesRes.json();
            console.log('âœ“ Nodes loaded:', nodes.length);
            
            // Load edges
            const edgesRes = await fetch('map_data/edges.json');
            if (!edgesRes.ok) throw new Error('Failed to load edges.json');
            edges = await edgesRes.json();
            console.log('âœ“ Edges loaded:', edges.length);
        }
        
        function initMap() {
            const center = metadata.center || { lat: 39.95, lon: -75.19 };
            map = L.map('map').setView([center.lat, center.lon], 14);
            
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
                maxZoom: 19
            }).addTo(map);
            
            map.on('click', handleMapClick);
        }
        
        function drawNetwork() {
            // Clear existing
            networkLayers.forEach(layer => map.removeLayer(layer));
            networkLayers = [];
            
            console.log('Drawing network...');
            
            edges.forEach(edge => {
                if (!edge.geometry || edge.geometry.length < 2) return;
                
                const shade = (edge.shade && edge.shade[currentScenario]) || 0;
                const coords = edge.geometry.map(c => [c[1], c[0]]); // [lat, lon]
                
                const layer = L.polyline(coords, {
                    color: getShadeColor(shade),
                    weight: 2,
                    opacity: 0.6
                }).addTo(map);
                
                networkLayers.push(layer);
            });
            
            console.log('âœ“ Network drawn:', networkLayers.length, 'segments');
        }
        
        function getShadeColor(shade) {
            if (shade < 0.2) return '#d32f2f';
            if (shade < 0.4) return '#f57c00';
            if (shade < 0.6) return '#fbc02d';
            if (shade < 0.8) return '#689f38';
            return '#388e3c';
        }
        
        function setupControls() {
            const select = document.getElementById('scenario');
            select.innerHTML = '';
            scenarios.forEach(s => {
                const option = document.createElement('option');
                option.value = s.id;
                option.textContent = s.name;
                select.appendChild(option);
            });
            
            select.value = currentScenario;
            select.addEventListener('change', (e) => {
                currentScenario = e.target.value;
                drawNetwork();
                if (originNode && destNode) calculateRoutes();
            });
            
            document.getElementById('reset').addEventListener('click', reset);
        }
        
        function handleMapClick(e) {
            const nearest = findNearestNode(e.latlng.lat, e.latlng.lng);
            
            if (!originNode) {
                setOrigin(nearest);
            } else if (!destNode) {
                setDestination(nearest);
                calculateRoutes();
            } else {
                reset();
                setOrigin(nearest);
            }
        }
        
        function findNearestNode(lat, lon) {
            let nearest = nodes[0];
            let minDist = Infinity;
            
            nodes.forEach(node => {
                const dist = Math.pow(node.lat - lat, 2) + Math.pow(node.lon - lon, 2);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = node;
                }
            });
            
            return nearest;
        }
        
        function setOrigin(node) {
            originNode = node;
            if (originMarker) map.removeLayer(originMarker);
            originMarker = L.circleMarker([node.lat, node.lon], {
                radius: 8,
                fillColor: '#2196F3',
                color: 'white',
                weight: 2,
                fillOpacity: 1
            }).addTo(map);
        }
        
        function setDestination(node) {
            destNode = node;
            if (destMarker) map.removeLayer(destMarker);
            destMarker = L.circleMarker([node.lat, node.lon], {
                radius: 8,
                fillColor: '#f44336',
                color: 'white',
                weight: 2,
                fillOpacity: 1
            }).addTo(map);
        }
        
        function calculateRoutes() {
            clearRoutes();
            
            const shortest = dijkstra(originNode.id, destNode.id, false);
            const shadiest = dijkstra(originNode.id, destNode.id, true);
            
            drawRoute(shortest, '#2196F3', 'Shortest');
            drawRoute(shadiest, '#4CAF50', 'Shadiest');
            
            showMetrics(shortest, shadiest);
        }
        
        function dijkstra(startId, endId, useShade) {
            const dist = {};
            const prev = {};
            const unvisited = new Set();
            
            nodes.forEach(node => {
                dist[node.id] = Infinity;
                unvisited.add(node.id);
            });
            dist[startId] = 0;
            
            while (unvisited.size > 0) {
                let current = null;
                let minDist = Infinity;
                unvisited.forEach(nodeId => {
                    if (dist[nodeId] < minDist) {
                        minDist = dist[nodeId];
                        current = nodeId;
                    }
                });
                
                if (current === null || current === endId) break;
                unvisited.delete(current);
                
                edges.forEach(edge => {
                    if (edge.source === current && unvisited.has(edge.target)) {
                        const shade = (edge.shade && edge.shade[currentScenario]) || 0;
                        const cost = useShade ? edge.length * (1 - 0.3 * shade) : edge.length;
                        const alt = dist[current] + cost;
                        
                        if (alt < dist[edge.target]) {
                            dist[edge.target] = alt;
                            prev[edge.target] = current;
                        }
                    }
                });
            }
            
            // Reconstruct path
            const path = [];
            let current = endId;
            while (current !== undefined) {
                path.unshift(current);
                current = prev[current];
            }
            
            // Calculate metrics
            let totalLength = 0;
            let totalShade = 0;
            
            for (let i = 0; i < path.length - 1; i++) {
                const edge = edges.find(e => e.source === path[i] && e.target === path[i+1]);
                if (edge) {
                    totalLength += edge.length;
                    const shade = (edge.shade && edge.shade[currentScenario]) || 0;
                    totalShade += shade * edge.length;
                }
            }
            
            return {
                path,
                distance: totalLength,
                avgShade: totalLength > 0 ? totalShade / totalLength : 0
            };
        }
        
        function drawRoute(route, color, label) {
            const coords = route.path.map(nodeId => {
                const node = nodes.find(n => n.id === nodeId);
                return [node.lat, node.lon];
            });
            
            const layer = L.polyline(coords, {
                color: color,
                weight: 4,
                opacity: 0.8
            }).bindPopup(`<strong>${label}</strong><br>
                Distance: ${route.distance.toFixed(0)}m<br>
                Avg Shade: ${(route.avgShade * 100).toFixed(1)}%`);
            
            layer.addTo(map);
            routeLayers.push(layer);
        }
        
        function showMetrics(shortest, shadiest) {
            document.getElementById('metrics').style.display = 'block';
            document.getElementById('shortest-dist').textContent = `${shortest.distance.toFixed(0)}m`;
            document.getElementById('shadiest-dist').textContent = `${shadiest.distance.toFixed(0)}m`;
            
            const detourPct = ((shadiest.distance - shortest.distance) / shortest.distance * 100).toFixed(1);
            document.getElementById('detour').textContent = `+${detourPct}%`;
            
            const shadeGain = ((shadiest.avgShade - shortest.avgShade) * 100).toFixed(1);
            document.getElementById('shade-gain').textContent = `+${shadeGain}%`;
        }
        
        function clearRoutes() {
            routeLayers.forEach(layer => map.removeLayer(layer));
            routeLayers = [];
            document.getElementById('metrics').style.display = 'none';
        }
        
        function reset() {
            if (originMarker) map.removeLayer(originMarker);
            if (destMarker) map.removeLayer(destMarker);
            originNode = null;
            destNode = null;
            originMarker = null;
            destMarker = null;
            clearRoutes();
        }
        
        // Start
        init();
    </script>
</body>
</html>
