<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shade-Optimized Routing Calculator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Header section - ABOVE the map */
        #header {
            background: white;
            border-bottom: 2px solid #e0e0e0;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        
        #header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        /* Left side - Scenario controls */
        #scenario-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }
        
        select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            min-width: 180px;
        }
        
        button {
            padding: 8px 16px;
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        
        button:hover {
            background: #357ae8;
        }
        
        /* Right side - Metrics (ALWAYS VISIBLE, blank when no routes) */
        #metrics-section {
            background: #f8f9fa;
            padding: 10px 20px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            min-height: 60px;
            display: flex;
            align-items: center;
        }
        
        #metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, auto);
            gap: 20px;
            width: 100%;
        }
        
        .metric {
            text-align: center;
            min-width: 80px;
        }
        
        .metric-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .metric-value {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-top: 4px;
        }
        
        .metric-value.empty {
            color: #bbb;
        }
        
        .metric-value.positive {
            color: #2196F3;
        }
        
        .metric-value.neutral {
            color: #ff6b9d;
        }
        
        /* Instructions bar */
        #instructions-bar {
            background: #e3f2fd;
            padding: 10px 20px;
            border-bottom: 1px solid #90caf9;
            font-size: 13px;
            text-align: center;
            color: #1565c0;
        }
        
        /* Map container */
        #map {
            flex: 1;
            width: 100%;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px 40px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 2000;
            text-align: center;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4285f4;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            #header-content {
                flex-direction: column;
                align-items: stretch;
            }
            
            #metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Loading network data...</p>
    </div>
    
    <!-- Header section - ABOVE map -->
    <div id="header">
        <div id="header-content">
            <!-- Left: Scenario controls -->
            <div id="scenario-section">
                <div class="title">ðŸŒ³ Shade Routing</div>
                
                <div class="control-group">
                    <label for="scenario">Scenario:</label>
                    <select id="scenario">
                        <option value="summer_midday">Summer Midday</option>
                    </select>
                </div>
                
                <button id="reset">Reset</button>
            </div>
            
            <!-- Right: Metrics (ALWAYS VISIBLE, shows dashes when empty) -->
            <div id="metrics-section">
                <div id="metrics-grid">
                    <div class="metric">
                        <div class="metric-label">Shortest</div>
                        <div class="metric-value empty" id="shortest-dist">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Shadiest</div>
                        <div class="metric-value empty" id="shadiest-dist">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Detour</div>
                        <div class="metric-value empty" id="detour">-</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Shade Gain</div>
                        <div class="metric-value empty" id="shade-gain">-</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Instructions bar -->
    <div id="instructions-bar">
        <strong>How to use:</strong> Click once to set origin (blue marker), click again to set destination (red marker). Routes compute automatically: <strong style="color: #ff6b9d;">Shortest (pink)</strong> vs <strong style="color: #2196F3;">Shadiest (blue)</strong>.
    </div>
    
    <!-- Map container -->
    <div id="map"></div>
    
    <script>
        let map, nodes = [], edges = [], scenarios = [], metadata = {};
        let currentScenario = 'summer_midday';
        let originNode = null, destNode = null;
        let originMarker = null, destMarker = null;
        let networkLayers = [];
        let routeLayers = [];
        
        async function init() {
            try {
                await loadData();
                initMap();
                drawNetwork();
                setupControls();
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('loading').innerHTML = 
                    `<div style="color: #c00; padding: 20px;">
                        <strong>Error loading map:</strong><br>
                        ${error.message}
                    </div>`;
            }
        }
        
        async function loadData() {
            console.log('Loading data files...');
            
            const metadataRes = await fetch('map_data/metadata.json');
            if (!metadataRes.ok) throw new Error('Failed to load metadata.json');
            metadata = await metadataRes.json();
            console.log('âœ“ Metadata loaded');
            
            const scenariosRes = await fetch('map_data/scenarios.json');
            if (!scenariosRes.ok) throw new Error('Failed to load scenarios.json');
            scenarios = await scenariosRes.json();
            console.log('âœ“ Scenarios loaded:', scenarios.length);
            
            const nodesRes = await fetch('map_data/nodes.json');
            if (!nodesRes.ok) throw new Error('Failed to load nodes.json');
            nodes = await nodesRes.json();
            console.log('âœ“ Nodes loaded:', nodes.length);
            
            const edgesRes = await fetch('map_data/edges.json');
            if (!edgesRes.ok) throw new Error('Failed to load edges.json');
            edges = await edgesRes.json();
            console.log('âœ“ Edges loaded:', edges.length);
        }
        
        function initMap() {
            const center = metadata.center || { lat: 39.95, lon: -75.19 };
            map = L.map('map').setView([center.lat, center.lon], 14);
            
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                maxZoom: 19
            }).addTo(map);
            
            map.on('click', handleMapClick);
        }
        
        function drawNetwork() {
            networkLayers.forEach(layer => map.removeLayer(layer));
            networkLayers = [];
            
            console.log('Drawing network...');
            
            edges.forEach(edge => {
                if (!edge.geometry || edge.geometry.length < 2) return;
                
                const shade = (edge.shade && edge.shade[currentScenario]) || 0;
                const coords = edge.geometry.map(c => [c[1], c[0]]);
                
                const layer = L.polyline(coords, {
                    color: getShadeColor(shade),
                    weight: 2,
                    opacity: 0.6
                }).addTo(map);
                
                networkLayers.push(layer);
            });
            
            console.log('âœ“ Network drawn:', networkLayers.length, 'segments');
        }
        
        function getShadeColor(shade) {
            if (shade < 0.2) return '#d32f2f';
            if (shade < 0.4) return '#f57c00';
            if (shade < 0.6) return '#fbc02d';
            if (shade < 0.8) return '#689f38';
            return '#388e3c';
        }
        
        function setupControls() {
            const select = document.getElementById('scenario');
            select.innerHTML = '';
            scenarios.forEach(s => {
                const option = document.createElement('option');
                option.value = s.id;
                option.textContent = s.name;
                select.appendChild(option);
            });
            
            select.value = currentScenario;
            select.addEventListener('change', (e) => {
                currentScenario = e.target.value;
                drawNetwork();
                if (originNode && destNode) calculateRoutes();
            });
            
            document.getElementById('reset').addEventListener('click', reset);
        }
        
        function handleMapClick(e) {
            const nearest = findNearestNode(e.latlng.lat, e.latlng.lng);
            
            if (!originNode) {
                setOrigin(nearest);
            } else if (!destNode) {
                setDestination(nearest);
                calculateRoutes();
            } else {
                reset();
                setOrigin(nearest);
            }
        }
        
        function findNearestNode(lat, lon) {
            let nearest = nodes[0];
            let minDist = Infinity;
            
            nodes.forEach(node => {
                const dist = Math.pow(node.lat - lat, 2) + Math.pow(node.lon - lon, 2);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = node;
                }
            });
            
            return nearest;
        }
        
        function setOrigin(node) {
            originNode = node;
            if (originMarker) map.removeLayer(originMarker);
            originMarker = L.circleMarker([node.lat, node.lon], {
                radius: 8,
                fillColor: '#2196F3',
                color: 'white',
                weight: 2,
                fillOpacity: 1
            }).addTo(map);
        }
        
        function setDestination(node) {
            destNode = node;
            if (destMarker) map.removeLayer(destMarker);
            destMarker = L.circleMarker([node.lat, node.lon], {
                radius: 8,
                fillColor: '#f44336',
                color: 'white',
                weight: 2,
                fillOpacity: 1
            }).addTo(map);
        }
        
        function calculateRoutes() {
            clearRoutes();
            
            const shortest = dijkstra(originNode.id, destNode.id, false);
            const shadiest = dijkstra(originNode.id, destNode.id, true);
            
            // Shortest route = PINK (#ff6b9d)
            drawRoute(shortest, '#ff6b9d', 'Shortest Route');
            
            // Shadiest route = BLUE (#2196F3)
            drawRoute(shadiest, '#2196F3', 'Shadiest Route');
            
            showMetrics(shortest, shadiest);
        }
        
        function dijkstra(startId, endId, useShade) {
            const dist = {};
            const prev = {};
            const unvisited = new Set();
            
            nodes.forEach(node => {
                dist[node.id] = Infinity;
                unvisited.add(node.id);
            });
            dist[startId] = 0;
            
            while (unvisited.size > 0) {
                let current = null;
                let minDist = Infinity;
                unvisited.forEach(nodeId => {
                    if (dist[nodeId] < minDist) {
                        minDist = dist[nodeId];
                        current = nodeId;
                    }
                });
                
                if (current === null || current === endId) break;
                unvisited.delete(current);
                
                edges.forEach(edge => {
                    if (edge.source === current && unvisited.has(edge.target)) {
                        const shade = (edge.shade && edge.shade[currentScenario]) || 0;
                        const cost = useShade ? edge.length * (1 - 0.3 * shade) : edge.length;
                        const alt = dist[current] + cost;
                        
                        if (alt < dist[edge.target]) {
                            dist[edge.target] = alt;
                            prev[edge.target] = current;
                        }
                    }
                });
            }
            
            const path = [];
            let current = endId;
            while (current !== undefined) {
                path.unshift(current);
                current = prev[current];
            }
            
            let totalLength = 0;
            let totalShade = 0;
            
            for (let i = 0; i < path.length - 1; i++) {
                const edge = edges.find(e => e.source === path[i] && e.target === path[i+1]);
                if (edge) {
                    totalLength += edge.length;
                    const shade = (edge.shade && edge.shade[currentScenario]) || 0;
                    totalShade += shade * edge.length;
                }
            }
            
            return {
                path,
                distance: totalLength,
                avgShade: totalLength > 0 ? totalShade / totalLength : 0
            };
        }
        
        function drawRoute(route, color, label) {
            const coords = route.path.map(nodeId => {
                const node = nodes.find(n => n.id === nodeId);
                return [node.lat, node.lon];
            });
            
            const layer = L.polyline(coords, {
                color: color,
                weight: 5,
                opacity: 0.9
            }).bindPopup(`<strong>${label}</strong><br>
                Distance: ${route.distance.toFixed(0)}m<br>
                Avg Shade: ${(route.avgShade * 100).toFixed(1)}%`);
            
            layer.addTo(map);
            routeLayers.push(layer);
        }
        
        function showMetrics(shortest, shadiest) {
            // Update values and remove 'empty' class
            const shortestEl = document.getElementById('shortest-dist');
            const shadiestEl = document.getElementById('shadiest-dist');
            const detourEl = document.getElementById('detour');
            const shadeGainEl = document.getElementById('shade-gain');
            
            shortestEl.textContent = `${shortest.distance.toFixed(0)}m`;
            shortestEl.className = 'metric-value neutral';
            
            shadiestEl.textContent = `${shadiest.distance.toFixed(0)}m`;
            shadiestEl.className = 'metric-value positive';
            
            const detourPct = ((shadiest.distance - shortest.distance) / shortest.distance * 100).toFixed(1);
            detourEl.textContent = `+${detourPct}%`;
            detourEl.className = 'metric-value neutral';
            
            const shadeGain = ((shadiest.avgShade - shortest.avgShade) * 100).toFixed(1);
            shadeGainEl.textContent = `+${shadeGain}%`;
            shadeGainEl.className = 'metric-value positive';
        }
        
        function clearRoutes() {
            routeLayers.forEach(layer => map.removeLayer(layer));
            routeLayers = [];
            
            // Reset metrics to dashes with 'empty' class
            const metricValues = document.querySelectorAll('.metric-value');
            metricValues.forEach(el => {
                el.textContent = '-';
                el.className = 'metric-value empty';
            });
        }
        
        function reset() {
            if (originMarker) map.removeLayer(originMarker);
            if (destMarker) map.removeLayer(destMarker);
            originNode = null;
            destNode = null;
            originMarker = null;
            destMarker = null;
            clearRoutes();
        }
        
        init();
    </script>
</body>
</html>
